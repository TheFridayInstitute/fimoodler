% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/sql_build.R
\name{build_sql_in}
\alias{build_sql_in}
\title{Build a SQL IN statement.}
\usage{
build_sql_in(var_names, values)
}
\arguments{
\item{var_names}{A character vector specifying the names of the database
columns to which the condition applies. If \code{values} is a vector,
\code{names} should have a length of 1. If \code{values} is a data frame,
\code{names} should have a length of \code{ncol(values)}.}

\item{values}{A vector or data frame containing values to match on. Factors
will be converted to strings. Rows of a data frame are treated as tuples.}
}
\value{
A string of format \code{"name IN (value1, value2, ...)"} for vector
  inputs and \code{"(name1, name2) IN ((name1value1, name2value1), ...)"} for
  data frames.
}
\description{
Returns SQL IN statement as a string. Supports multi-variable value matching
with tuples.
}
\details{
Concatenates values in a vector and returns them in a SQL conditional format.
This is necessary since Friday Institute researchers are given read-only
access to the database.  Otherwise, you could use dplyr join commands with
copy=TRUE, which would create a temporary table in the database, so the
database can handle the calculations.  If this breaks, you can always pull
the entire table and do subsetting locally, but that's obviously expensive.
}
\examples{
\dontrun{
courseids <- c(1, 2, 3)
build_sql_in("courseid", courseids)

# tuple
tuple <- tribble(
  ~courseid, ~userid,
  1,         1,
  1,         2,
  2,         3,
  2,         4
)
build_sql_in(c("courseid", "userid"), tuple)
}
}
\keyword{internal}
